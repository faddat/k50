<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Hub Tattoo</title>
    <style>
        body {
            margin: 0;
            background: #0d041a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: none;
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            z-index: 10;
            display: flex;
            gap: 10px;
            flex-direction: column;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .controls button {
            padding: 10px 15px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 5px;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
        }
        .controls button:hover, .controls button.active {
            background: #ffd700;
            color: #0d041a;
            transform: scale(1.05);
        }
        .label {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 35px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            z-index: 10;
        }
        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #ffd700;
            font-family: monospace;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .audio-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .audio-controls button {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
        }
        .audio-controls button:hover {
            background: #ffd700;
            color: #0d041a;
        }
        .mode-switch {
            position: fixed;
            top: 20px;
            right: 100px;
            z-index: 10;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .mode-switch button {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
        }
        .mode-switch button:hover {
            background: #ffd700;
            color: #0d041a;
        }
        .microphone-control {
            position: fixed;
            top: 20px;
            right: 250px;
            z-index: 10;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .node-count-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .node-count-container input {
            width: 60px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 8px;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            text-align: center;
        }
        .node-count-container input:focus {
            outline: none;
            border-color: #fff;
            background: rgba(255, 215, 0, 0.3);
        }
        .node-count-container .label {
            position: static;
            margin: 0;
            font-size: 24px;
        }
        .sliding-element {
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .hidden {
            transform: translateY(-150%);
            opacity: 0;
            pointer-events: none;
        }
        .hidden-bottom {
            transform: translateY(150%);
            opacity: 0;
            pointer-events: none;
        }
        .mode-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Orbitron', sans-serif;
            color: #ffd700;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 10;
            text-align: right;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .mode-indicator.visible {
            opacity: 1;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
    <!-- Load Stats.js first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <div class="controls sliding-element">
        <button class="node-btn" data-nodes="1">1</button>
        <button class="node-btn" data-nodes="4">4</button>
        <button class="node-btn active" data-nodes="9">9</button>
        <button onclick="toggleDebug()">Debug</button>
    </div>
    <div class="audio-controls sliding-element">
        <button onclick="toggleMusic()">ðŸŽµ Toggle Music</button>
    </div>
    <div class="microphone-control sliding-element">
        <button onclick="toggleMicrophone()">ðŸŽ¤ Toggle Microphone</button>
    </div>
    <div class="node-count-container sliding-element">
        <div class="label" id="label">Kn = </div>
        <input type="number" id="nodeCount" min="3" max="200" value="69">
    </div>
    <div class="mode-indicator">Mode: Classic</div>
    <div id="debug"></div>
    
    <script>
        // Debug helper
        const debug = document.getElementById('debug');
        function log(msg) {
            if (debug.style.display === 'block') {
                debug.innerHTML = msg + '<br>' + debug.innerHTML;
                if (debug.innerHTML.split('<br>').length > 10) {
                    debug.innerHTML = debug.innerHTML.split('<br>').slice(0, 10).join('<br>');
                }
            }
        }
        function toggleDebug() {
            debug.style.display = debug.style.display === 'none' ? 'block' : 'none';
        }

        // Stats setup with error handling
        let stats = null;
        try {
            if (typeof Stats === 'function') {
                stats = new Stats();
                stats.showPanel(0);
                document.body.appendChild(stats.dom);
                stats.dom.style.position = 'fixed';
                stats.dom.style.top = '10px';
                stats.dom.style.left = '10px';
                stats.dom.style.zIndex = '1000';
                log('Stats initialized successfully');
            } else {
                log('Warning: Stats.js not loaded properly');
            }
        } catch (error) {
            log('Error initializing Stats: ' + error.message);
        }

        // Music setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let musicPlaying = false;
        let musicSource = null;
        let analyser = null;
        let audioData = null;

        // Generative techno synthesizer
        class TechnoSynth {
            constructor(context) {
                this.context = context;
                this.analyser = context.createAnalyser();
                this.analyser.fftSize = 256;
                this.audioData = new Uint8Array(this.analyser.frequencyBinCount);
                
                // Create nodes
                this.masterGain = context.createGain();
                this.masterGain.gain.value = 0.3; // Reduced overall volume
                this.masterGain.connect(this.analyser);
                this.analyser.connect(context.destination);
                
                // Create compressor for better sound
                this.compressor = context.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.analyser);
                
                // Create oscillators with more musical frequencies
                this.bassOsc = context.createOscillator();
                this.bassOsc.type = 'triangle'; // Changed to triangle for softer bass
                this.bassOsc.frequency.value = 55; // A1
                
                this.midOsc = context.createOscillator();
                this.midOsc.type = 'sine'; // Changed to sine for smoother sound
                this.midOsc.frequency.value = 110; // A2
                
                this.highOsc = context.createOscillator();
                this.highOsc.type = 'sine'; // Changed to sine
                this.highOsc.frequency.value = 220; // A3
                
                // Individual gain nodes for better mixing
                this.bassGain = context.createGain();
                this.bassGain.gain.value = 0.4;
                
                this.midGain = context.createGain();
                this.midGain.gain.value = 0.2;
                
                this.highGain = context.createGain();
                this.highGain.gain.value = 0.1;
                
                // Create filters with gentler settings
                this.bassFilter = context.createBiquadFilter();
                this.bassFilter.type = 'lowpass';
                this.bassFilter.frequency.value = 150;
                this.bassFilter.Q.value = 1;
                
                this.midFilter = context.createBiquadFilter();
                this.midFilter.type = 'bandpass';
                this.midFilter.frequency.value = 800;
                this.midFilter.Q.value = 0.5;
                
                this.highFilter = context.createBiquadFilter();
                this.highFilter.type = 'highpass';
                this.highFilter.frequency.value = 1500;
                this.highFilter.Q.value = 0.5;
                
                // Create LFOs with gentler modulation
                this.bassLFO = context.createOscillator();
                this.bassLFO.frequency.value = 0.2;
                this.bassLFOGain = context.createGain();
                this.bassLFOGain.gain.value = 10;
                
                this.midLFO = context.createOscillator();
                this.midLFO.frequency.value = 0.1;
                this.midLFOGain = context.createGain();
                this.midLFOGain.gain.value = 15;
                
                this.highLFO = context.createOscillator();
                this.highLFO.frequency.value = 0.15;
                this.highLFOGain = context.createGain();
                this.highLFOGain.gain.value = 20;
                
                // Connect everything
                this.bassOsc.connect(this.bassGain);
                this.bassGain.connect(this.bassFilter);
                this.bassFilter.connect(this.masterGain);
                
                this.midOsc.connect(this.midGain);
                this.midGain.connect(this.midFilter);
                this.midFilter.connect(this.masterGain);
                
                this.highOsc.connect(this.highGain);
                this.highGain.connect(this.highFilter);
                this.highFilter.connect(this.masterGain);
                
                // Start oscillators
                this.bassOsc.start();
                this.midOsc.start();
                this.highOsc.start();
                this.bassLFO.start();
                this.midLFO.start();
                this.highLFO.start();

                // Create rhythm
                this.rhythmInterval = 200; // 120 BPM
                this.lastRhythmTime = 0;
            }
            
            update(seed) {
                const now = this.context.currentTime;
                
                // Create a rhythm pattern
                if (now - this.lastRhythmTime >= this.rhythmInterval / 1000) {
                    this.lastRhythmTime = now;
                    this.bassGain.gain.setValueAtTime(0.4, now);
                    this.bassGain.gain.exponentialRampToValueAtTime(0.1, now + 0.1);
                }

                // Use seed for subtle variations
                const bassFreq = 55 + (seed % 5);
                const midFreq = 110 + (seed % 10);
                const highFreq = 220 + (seed % 15);
                
                // Smoother frequency changes
                this.bassOsc.frequency.setTargetAtTime(bassFreq, now, 0.1);
                this.midOsc.frequency.setTargetAtTime(midFreq, now, 0.1);
                this.highOsc.frequency.setTargetAtTime(highFreq, now, 0.1);
                
                // Gentler filter modulation
                const bassMod = Math.sin(now * 0.2) * 30 + 150;
                const midMod = Math.sin(now * 0.1) * 100 + 800;
                const highMod = Math.sin(now * 0.15) * 200 + 1500;
                
                this.bassFilter.frequency.setTargetAtTime(bassMod, now, 0.1);
                this.midFilter.frequency.setTargetAtTime(midMod, now, 0.1);
                this.highFilter.frequency.setTargetAtTime(highMod, now, 0.1);
            }
            
            getAnalyser() {
                return this.analyser;
            }
            
            getAudioData() {
                return this.audioData;
            }
        }

        let synth = null;
        async function toggleMusic() {
            try {
                if (!synth) {
                    synth = new TechnoSynth(audioContext);
                    analyser = synth.getAnalyser();
                    audioData = synth.getAudioData();
                    musicPlaying = true;
                } else {
                    if (musicPlaying) {
                        synth.masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                        musicPlaying = false;
                    } else {
                        synth.masterGain.gain.setValueAtTime(0.5, audioContext.currentTime);
                        musicPlaying = true;
                    }
                }
            } catch (error) {
                log('Error toggling music: ' + error.message);
                console.error('Music error:', error);
            }
        }

        // Scene setup with debugging
        try {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d041a);
            log('Scene created');

            // Create background canvas
            const backgroundCanvas = document.createElement('canvas');
            backgroundCanvas.id = 'background';
            document.body.appendChild(backgroundCanvas);
            const bgCtx = backgroundCanvas.getContext('2d');
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;

            // Create background particles and flow fields
            const particles = [];
            const particleCount = 200; // Increased particle count
            const flowField = [];
            const fieldSize = 20;
            const cols = Math.ceil(window.innerWidth / fieldSize);
            const rows = Math.ceil(window.innerHeight / fieldSize);

            // Initialize flow field
            for (let i = 0; i < cols; i++) {
                flowField[i] = [];
                for (let j = 0; j < rows; j++) {
                    flowField[i][j] = {
                        angle: Math.random() * Math.PI * 2,
                        strength: 0.5
                    };
                }
            }

            // Create particles with more variety
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 4 + 1,
                    speed: Math.random() * 2 + 1,
                    angle: Math.random() * Math.PI * 2,
                    hue: Math.random() * 360,
                    life: Math.random(),
                    maxLife: Math.random() * 100 + 50
                });
            }

            // Update flow field based on audio
            function updateFlowField(bassLevel, midLevel, trebleLevel) {
                const time = Date.now() * 0.001;
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const x = i * fieldSize;
                        const y = j * fieldSize;
                        
                        // Create swirling patterns based on audio
                        const angle = Math.sin(x * 0.01 + time) * Math.cos(y * 0.01 + time) * Math.PI * 2;
                        const strength = 0.5 + (bassLevel * 0.3) + (Math.sin(time + x * 0.02) * 0.2);
                        
                        flowField[i][j] = {
                            angle: angle,
                            strength: strength
                        };
                    }
                }
            }

            // Background animation function
            function animateBackground(bassLevel, midLevel, trebleLevel) {
                bgCtx.fillStyle = 'rgba(13, 4, 26, 0.1)';
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

                // Update flow field
                updateFlowField(bassLevel, midLevel, trebleLevel);

                // Update and draw particles
                particles.forEach(particle => {
                    // Get flow field influence
                    const col = Math.floor(particle.x / fieldSize);
                    const row = Math.floor(particle.y / fieldSize);
                    if (col >= 0 && col < cols && row >= 0 && row < rows) {
                        const field = flowField[col][row];
                        particle.angle = field.angle;
                        particle.speed = field.strength * 2;
                    }

                    // Update position
                    particle.x += Math.cos(particle.angle) * particle.speed;
                    particle.y += Math.sin(particle.angle) * particle.speed;

                    // Wrap around screen
                    if (particle.x < 0) particle.x = window.innerWidth;
                    if (particle.x > window.innerWidth) particle.x = 0;
                    if (particle.y < 0) particle.y = window.innerHeight;
                    if (particle.y > window.innerHeight) particle.y = 0;

                    // Update life and color
                    particle.life += 0.1;
                    if (particle.life > particle.maxLife) {
                        particle.life = 0;
                        particle.hue = (particle.hue + trebleLevel * 50) % 360;
                    }

                    // Draw particle with audio-reactive properties
                    const size = particle.size * (1 + bassLevel * 2);
                    const alpha = 0.3 + (midLevel * 0.7) * (1 - particle.life / particle.maxLife);
                    bgCtx.fillStyle = `hsla(${particle.hue}, 100%, 70%, ${alpha})`;
                    bgCtx.beginPath();
                    bgCtx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    bgCtx.fill();
                });

                // Add audio-reactive gradient overlay
                const gradient = bgCtx.createRadialGradient(
                    window.innerWidth / 2,
                    window.innerHeight / 2,
                    0,
                    window.innerWidth / 2,
                    window.innerHeight / 2,
                    Math.max(window.innerWidth, window.innerHeight) * 0.5
                );
                
                const time = Date.now() * 0.001;
                const bassHue = (time * 20) % 360;
                const midHue = (time * 20 + 120) % 360;
                const trebleHue = (time * 20 + 240) % 360;
                
                const bassColor = `hsla(${bassHue}, 100%, 50%, ${bassLevel * 0.15})`;
                const midColor = `hsla(${midHue}, 100%, 50%, ${midLevel * 0.15})`;
                const trebleColor = `hsla(${trebleHue}, 100%, 50%, ${trebleLevel * 0.15})`;
                
                gradient.addColorStop(0, bassColor);
                gradient.addColorStop(0.5, midColor);
                gradient.addColorStop(1, trebleColor);
                
                bgCtx.globalCompositeOperation = 'overlay';
                bgCtx.fillStyle = gradient;
                bgCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
                bgCtx.globalCompositeOperation = 'source-over';
            }

            // Update background on resize
            window.addEventListener('resize', () => {
                backgroundCanvas.width = window.innerWidth;
                backgroundCanvas.height = window.innerHeight;
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Viewport helper
            function getViewportSize() {
                return {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    aspect: window.innerWidth / window.innerHeight,
                    min: Math.min(window.innerWidth, window.innerHeight),
                    max: Math.max(window.innerWidth, window.innerHeight)
                };
            }

            // Camera setup
            const viewport = getViewportSize();
            const camera = new THREE.OrthographicCamera(
                -viewport.width / 2,
                viewport.width / 2,
                viewport.height / 2,
                -viewport.height / 2,
                1,
                2000
            );
            camera.position.z = 1000;
            log('Camera initialized at z=' + camera.position.z);

            // Renderer setup with error checking and performance optimizations
            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            
            if (!renderer) {
                throw new Error('Failed to create WebGL renderer');
            }
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setAnimationLoop(animate); // Use setAnimationLoop for better performance
            renderer.domElement.style.position = 'fixed';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            document.body.appendChild(renderer.domElement);
            log('Renderer created with size: ' + viewport.width + 'x' + viewport.height);

            // Audio setup for microphone
            let microphoneAnalyser = null;
            let microphoneData = null;
            let isMicrophoneActive = false;

            async function setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioContext.createMediaStreamSource(stream);
                    microphoneAnalyser = audioContext.createAnalyser();
                    microphoneAnalyser.fftSize = 256;
                    microphoneData = new Uint8Array(microphoneAnalyser.frequencyBinCount);
                    source.connect(microphoneAnalyser);
                    isMicrophoneActive = true;
                    log('Microphone setup successful');
                } catch (error) {
                    log('Error setting up microphone: ' + error.message);
                }
            }

            // Update UI controls visibility
            let controlsTimeout;
            const topControls = document.querySelectorAll('.controls, .audio-controls, .microphone-control');
            const bottomControls = document.querySelectorAll('.node-count-container');
            const modeIndicator = document.querySelector('.mode-indicator');

            function showControls() {
                clearTimeout(controlsTimeout);
                topControls.forEach(element => {
                    element.classList.remove('hidden');
                });
                bottomControls.forEach(element => {
                    element.classList.remove('hidden-bottom');
                });
                modeIndicator.classList.add('visible');
                controlsTimeout = setTimeout(hideControls, 3000);
            }

            function hideControls() {
                topControls.forEach(element => {
                    element.classList.add('hidden');
                });
                bottomControls.forEach(element => {
                    element.classList.add('hidden-bottom');
                });
                modeIndicator.classList.remove('visible');
            }

            // Add space bar handler for mode switching
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Space' && !event.repeat) {
                    event.preventDefault(); // Prevent page scrolling
                    toggleVisualizationMode();
                }
            });

            // Function to toggle between visualization modes
            function toggleVisualizationMode() {
                isClassicMode = !isClassicMode;
                
                // Update mode indicator
                modeIndicator.textContent = `Mode: ${isClassicMode ? 'Classic' : 'Fluid'}`;
                modeIndicator.classList.add('visible');
                clearTimeout(controlsTimeout);
                controlsTimeout = setTimeout(hideControls, 3000);
                
                // Clear existing graph
                nodeSprites.forEach(sprite => scene.remove(sprite));
                edgeLines.forEach(line => scene.remove(line));
                nodeTrails.forEach(trail => scene.remove(trail));
                
                nodeSprites = [];
                edgeLines = [];
                nodeTrails = [];
                
                // Regenerate with current node count
                generateCompleteGraph(parseInt(nodeCountInput.value));
                renderGraph();
            }

            // Create node sprite with error checking
            function createNodeSprite(color) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    if (!ctx) {
                        throw new Error('Failed to get 2D context');
                    }

                    if (isClassicMode) {
                        // Classic mode: Simple dot with glow
                        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(0.3, color);
                        gradient.addColorStop(0.5, color.replace(')', ', 0.5)'));
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 256, 256);
                    } else {
                        // Fluid mode: Larger, more diffuse glow
                        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(0.2, color);
                        gradient.addColorStop(0.4, color.replace(')', ', 0.5)'));
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 256, 256);
                    }
                    
                    const texture = new THREE.Texture(canvas);
                    texture.needsUpdate = true;
                    
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthTest: false
                    });
                    
                    return new THREE.Sprite(material);
                } catch (error) {
                    log('Error creating sprite: ' + error.message);
                    throw error;
                }
            }

            // Create node trail
            function createNodeTrail(node, color) {
                const trailLength = 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(trailLength * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: new THREE.Color(color),
                    transparent: true,
                    opacity: 0.5,
                    linewidth: 3,
                    blending: THREE.AdditiveBlending
                });
                
                const trail = new THREE.Line(geometry, material);
                trail.userData = {
                    positions: new Array(trailLength).fill().map(() => ({ x: node.x, y: node.y })),
                    color: color
                };
                
                return trail;
            }

            // Create edge material with mode-specific settings
            function createEdgeMaterial() {
                if (isClassicMode) {
                    return new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        opacity: 0.8,
                        transparent: true,
                        blending: THREE.NormalBlending,
                        linewidth: 1
                    });
                } else {
                    return new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        opacity: 1.0,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        linewidth: 20
                    });
                }
            }

            // Create edge glow effect with maximum visibility
            function createEdgeGlow(edge, source, target) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    source.x, source.y, 0,
                    target.x, target.y, 0
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 1.0, // Full opacity
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    linewidth: 24 // Maximum line width
                });
                
                return new THREE.Line(geometry, material);
            }

            // Update node trail
            function updateNodeTrail(trail, node, audioLevel) {
                const positions = trail.geometry.attributes.position.array;
                const trailData = trail.userData;
                
                // Shift positions back
                trailData.positions.pop();
                trailData.positions.unshift({ x: node.x, y: node.y });
                
                // Update geometry
                trailData.positions.forEach((pos, i) => {
                    const t = i / trailData.positions.length;
                    positions[i * 3] = pos.x;
                    positions[i * 3 + 1] = pos.y;
                    positions[i * 3 + 2] = 0;
                    
                    // Update opacity based on position in trail
                    trail.material.opacity = (0.5 + audioLevel * 0.5) * (1 - t);
                });
                
                trail.geometry.attributes.position.needsUpdate = true;
                
                // Update color based on audio
                const hue = (Date.now() * 0.001 + audioLevel * 180) % 360;
                trail.material.color.setHSL(hue/360, 1, 0.7);
            }

            // Generate complete graph with geometric arrangement
            function generateCompleteGraph(n) {
                try {
                    const viewport = getViewportSize();
                    const radius = Math.min(viewport.width, viewport.height) * 0.4; // Adjusted radius for geometry
                    const angleIncrement = (2 * Math.PI) / n;
                    
                    graph.nodes = Array.from({ length: n }, (_, i) => {
                        const angle = i * angleIncrement;
                        return {
                            id: i,
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius,
                            vx: 0,
                            vy: 0,
                            color: `hsl(${(i * 360 / n) % 360}, 100%, 70%)`
                        };
                    });

                    graph.edges = [];
                    for (let i = 0; i < n; i++) {
                        for (let j = i + 1; j < n; j++) {
                            graph.edges.push({ source: i, target: j });
                        }
                    }

                    document.getElementById('label').textContent = `Kn = ${n}`;
                    log(`Generated graph with ${n} nodes and ${graph.edges.length} edges`);
                } catch (error) {
                    log('Error generating graph: ' + error.message);
                    throw error;
                }
            }

            // Render graph with error checking
            function renderGraph() {
                try {
                    // Remove existing elements
                    nodeSprites.forEach(sprite => scene.remove(sprite));
                    edgeLines.forEach(line => scene.remove(line));
                    nodeTrails.forEach(trail => scene.remove(trail));
                    
                    nodeSprites = [];
                    edgeLines = [];
                    nodeTrails = [];

                    // Add nodes and their trails
                    graph.nodes.forEach(node => {
                        const sprite = createNodeSprite(node.color);
                        sprite.position.set(node.x, node.y, 0);
                        sprite.scale.set(100, 100, 1);
                        nodeSprites.push(sprite);
                        scene.add(sprite);
                        
                        const trail = createNodeTrail(node, node.color);
                        nodeTrails.push(trail);
                        scene.add(trail);
                    });

                    // Add edges with enhanced visibility
                    graph.edges.forEach(edge => {
                        const source = graph.nodes[edge.source];
                        const target = graph.nodes[edge.target];
                        
                        // Create main edge line
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            source.x, source.y, 0,
                            target.x, target.y, 0
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const edgeMaterial = createEdgeMaterial();
                        const line = new THREE.Line(geometry, edgeMaterial);
                        edgeLines.push(line);
                        scene.add(line);
                        
                        // Add glow effect
                        const glow = createEdgeGlow(edge, source, target);
                        edgeLines.push(glow);
                        scene.add(glow);
                    });

                    log(`Rendered ${nodeSprites.length} nodes and ${edgeLines.length} edges`);
                } catch (error) {
                    log('Error rendering graph: ' + error.message);
                    throw error;
                }
            }

            // Force simulation with audio reactivity
            function simulate() {
                const viewport = getViewportSize();
                const bounds = Math.min(viewport.width, viewport.height) * 0.8;
                const charge = isClassicMode ? -800 : -1200; // Adjust forces based on mode
                const centerForce = isClassicMode ? 0.01 : 0.02;
                const damping = isClassicMode ? 0.95 : 0.98;
                
                // Initialize audio levels
                let bassLevel = 0;
                let midLevel = 0;
                let trebleLevel = 0;
                let overallLevel = 0;
                
                // Get audio data from both music and microphone
                if (analyser && musicPlaying) {
                    analyser.getByteFrequencyData(audioData);
                    bassLevel = (average(audioData.slice(0, 4)) / 255) * 2.5; // Increased sensitivity
                    midLevel = (average(audioData.slice(4, 12)) / 255) * 2.0;
                    trebleLevel = (average(audioData.slice(12, 24)) / 255) * 2.0;
                    overallLevel = (average(audioData) / 255) * 2.0;
                    if (synth) synth.update(9);
                }

                if (microphoneAnalyser && isMicrophoneActive) {
                    microphoneAnalyser.getByteFrequencyData(microphoneData);
                    const micBass = (average(microphoneData.slice(0, 4)) / 255) * 2.5;
                    const micMid = (average(microphoneData.slice(4, 12)) / 255) * 2.0;
                    const micTreble = (average(microphoneData.slice(12, 24)) / 255) * 2.0;
                    const micOverall = (average(microphoneData) / 255) * 2.0;
                    
                    // Combine music and microphone levels with increased sensitivity
                    bassLevel = Math.max(bassLevel, micBass * 2.0);
                    midLevel = Math.max(midLevel, micMid * 1.8);
                    trebleLevel = Math.max(trebleLevel, micTreble * 1.8);
                    overallLevel = Math.max(overallLevel, micOverall * 1.8);
                }

                function average(array) {
                    return array.reduce((a, b) => a + b, 0) / array.length;
                }

                // Animate background
                animateBackground(bassLevel, midLevel, trebleLevel);

                // Enhanced time-based modulation for psychedelic effects
                const time = Date.now() * 0.001;
                const pulse = Math.sin(time * 2) * 0.5 + 0.5;
                const swirl = Math.sin(time * 0.5) * 0.5 + 0.5;
                const wave = Math.sin(time * 3) * 0.5 + 0.5;

                // Update node trails only in fluid mode
                if (!isClassicMode) {
                    nodeTrails.forEach((trail, i) => {
                        const node = graph.nodes[i];
                        const audioLevel = (bassLevel + midLevel + trebleLevel) / 3;
                        updateNodeTrail(trail, node, audioLevel);
                    });
                }

                // Enhanced edge effects with mode-specific settings
                edgeLines.forEach((line, i) => {
                    const isGlow = i % 2 === 1;
                    if (isClassicMode && isGlow) {
                        line.visible = false;
                        return;
                    }
                    line.visible = true;
                    
                    const positions = line.geometry.attributes.position.array;
                    
                    if (isGlow) {
                        // Update glow line
                        positions[0] = source.x;
                        positions[1] = source.y;
                        positions[3] = target.x;
                        positions[4] = target.y;
                        
                        // Enhanced glow effect properties
                        const glowIntensity = 1.0 + (bassLevel * 0.4) + (pulse * 0.2); // Maximum intensity
                        const glowHue = ((time * 20 + i * 5) % 360);
                        line.material.color.setHSL(glowHue/360, 1, 1.0); // Full brightness
                        line.material.opacity = glowIntensity;
                        line.material.linewidth = 24 + (bassLevel * 4); // Maximum line width
                    } else {
                        // Enhanced wave effect to main edge line
                        const segments = 5;
                        for (let j = 0; j <= segments; j++) {
                            const t = j / segments;
                            const x = source.x + (target.x - source.x) * t;
                            const y = source.y + (target.y - source.y) * t;
                            const waveOffset = Math.sin(time * 2 + i * 0.1 + t * Math.PI) * (trebleLevel * 20);
                            positions[j * 3] = x + (target.y - source.y) / dist * waveOffset;
                            positions[j * 3 + 1] = y - (target.x - source.x) / dist * waveOffset;
                        }
                        
                        // Dynamic color based on audio and position
                        const hue = ((time * 20 + i * 10 + midLevel * 180) % 360);
                        const saturation = 1;
                        const brightness = 1.0 + trebleLevel * 0.2; // Full brightness
                        line.material.color.setHSL(hue/360, saturation, brightness);
                        line.material.opacity = 1.0 + (midLevel * 0.3) + (pulse * 0.2); // Full opacity
                        line.material.linewidth = 20 + (bassLevel * 4); // Maximum line width
                    }
                    
                    line.geometry.attributes.position.needsUpdate = true;
                });

                // Apply forces with enhanced audio reactivity
                graph.nodes.forEach((node, i) => {
                    let fx = 0, fy = 0;

                    // Enhanced repulsion with audio modulation
                    graph.nodes.forEach(other => {
                        if (node !== other) {
                            const dx = node.x - other.x;
                            const dy = node.y - other.y;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            const audioMod = 1 + (bassLevel * 0.5);
                            const force = (charge * audioMod) / (dist * dist + 100);
                            fx += force * dx / dist;
                            fy += force * dy / dist;
                        }
                    });

                    // Enhanced audio-reactive forces
                    if (musicPlaying || isMicrophoneActive) {
                        const angle = (i * 2 * Math.PI / graph.nodes.length) + (swirl * Math.PI * 2);
                        const bassForce = bassLevel * 50 * (1 + pulse * 0.5); // Increased force
                        const midForce = midLevel * 40 * (1 + Math.sin(time * 3) * 0.3); // Increased force
                        
                        // Add swirling motion
                        fx += Math.cos(angle) * bassForce;
                        fy += Math.sin(angle) * bassForce;
                        
                        // Add pulsing motion
                        fx += Math.cos(time + i) * midForce;
                        fy += Math.sin(time + i) * midForce;

                        // Enhanced size transitions with pulsing
                        const baseScale = 40 * (1 + midLevel * 0.8); // Reduced node size
                        const pulseScale = baseScale * (1 + pulse * 0.3);
                        const currentScale = nodeSprites[i].scale.x;
                        const newScale = currentScale + (pulseScale - currentScale) * 0.15;
                        nodeSprites[i].scale.set(newScale, newScale, 1);

                        // Enhanced color transitions with rainbow effect
                        const hue = ((i * 360 / graph.nodes.length) + (time * 20) + (overallLevel * 180)) % 360;
                        const saturation = 100;
                        const brightness = 60 + trebleLevel * 30 + pulse * 20;
                        node.color = `hsl(${hue}, ${saturation}%, ${brightness}%)`;
                        nodeSprites[i].material.color.setHSL(hue/360, saturation/100, brightness/100);
                        
                        // Add opacity modulation
                        nodeSprites[i].material.opacity = 0.7 + (trebleLevel * 0.3) + (pulse * 0.2);
                    }

                    // Organic boundary forces with softer containment
                    const distFromCenter = Math.sqrt(node.x * node.x + node.y * node.y);
                    const maxDist = bounds * (0.9 + bassLevel * 0.1); // Increased maximum distance
                    
                    if (distFromCenter > maxDist) {
                        // Softer boundary force that increases gradually
                        const boundaryForce = Math.pow((distFromCenter - maxDist) / maxDist, 2) * 0.5; // Reduced force
                        fx -= node.x * boundaryForce;
                        fy -= node.y * boundaryForce;
                    } else {
                        // Very gentle center attraction
                        const centerStrength = centerForce * (1 + (bassLevel + midLevel) * 0.2);
                        fx -= node.x * centerStrength;
                        fy -= node.y * centerStrength;
                    }

                    // Update velocity and position with smoother transitions
                    node.vx = (node.vx + fx * 0.1) * damping;
                    node.vy = (node.vy + fy * 0.1) * damping;
                    node.x += node.vx;
                    node.y += node.vy;

                    // Update node position
                    nodeSprites[i].position.set(node.x, node.y, 0);
                });

                // Update color intensity based on audio
                updateColorIntensity(bassLevel, midLevel, trebleLevel);
            }

            // Animation loop with error handling
            function animate() {
                try {
                    if (stats) stats.begin();
                    
                    simulate();
                    renderer.render(scene, camera);
                    
                    if (analyser && musicPlaying) {
                        analyser.getByteFrequencyData(audioData);
                        drawFrequencyBars(audioData);
                        drawWaveform(audioData);
                    }
                    
                    if (stats) stats.end();
                } catch (error) {
                    log('Error in animation loop: ' + error.message);
                    console.error('Animation error:', error);
                }
            }

            // Window resize handler
            window.addEventListener('resize', () => {
                try {
                    const viewport = getViewportSize();
                    camera.left = -viewport.width / 2;
                    camera.right = viewport.width / 2;
                    camera.top = viewport.height / 2;
                    camera.bottom = -viewport.height / 2;
                    camera.updateProjectionMatrix();
                    renderer.setSize(viewport.width, viewport.height);
                    log('Resized to: ' + viewport.width + 'x' + viewport.height);
                } catch (error) {
                    log('Error handling resize: ' + error.message);
                }
            });

            // Node count controls
            document.querySelectorAll('.node-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const n = parseInt(btn.dataset.nodes);
                    document.querySelectorAll('.node-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    generateCompleteGraph(n);
                    renderGraph();
                });
            });

            // Initialize
            generateCompleteGraph(69);
            renderGraph();
            log('Initialization complete');

            // Start music automatically
            document.addEventListener('DOMContentLoaded', async () => {
                try {
                    const message = document.createElement('div');
                    message.style.position = 'fixed';
                    message.style.top = '50%';
                    message.style.left = '50%';
                    message.style.transform = 'translate(-50%, -50%)';
                    message.style.background = 'rgba(0,0,0,0.8)';
                    message.style.color = '#ffd700';
                    message.style.padding = '20px';
                    message.style.borderRadius = '10px';
                    message.style.fontFamily = 'Orbitron, sans-serif';
                    message.style.cursor = 'pointer';
                    message.style.zIndex = '1000';
                    message.innerHTML = 'Click anywhere to start the experience';
                    document.body.appendChild(message);

                    const startAudio = async () => {
                        await toggleMusic();
                        message.remove();
                        document.removeEventListener('click', startAudio);
                    };

                    document.addEventListener('click', startAudio, { once: true });
                } catch (error) {
                    log('Error auto-starting music: ' + error.message);
                }
            });

            // Add control panel
            const controlPanel = document.createElement('div');
            controlPanel.style.position = 'fixed';
            controlPanel.style.top = 'auto';
            controlPanel.style.bottom = '10px';
            controlPanel.style.right = '10px';
            controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            controlPanel.style.padding = '10px';
            controlPanel.style.borderRadius = '5px';
            controlPanel.style.color = 'white';
            document.body.appendChild(controlPanel);

            // Add node count input in lower-left corner
            const nodeCountInput = document.createElement('input');
            nodeCountInput.type = 'number';
            nodeCountInput.min = '10';
            nodeCountInput.max = '200';
            nodeCountInput.value = '69';
            nodeCountInput.style.position = 'fixed';
            nodeCountInput.style.bottom = '20px';
            nodeCountInput.style.left = '120px';
            nodeCountInput.style.width = '60px';
            nodeCountInput.style.background = 'rgba(255, 215, 0, 0.2)';
            nodeCountInput.style.border = '1px solid #ffd700';
            nodeCountInput.style.color = '#ffd700';
            nodeCountInput.style.padding = '5px';
            nodeCountInput.style.borderRadius = '5px';
            nodeCountInput.style.fontFamily = 'Orbitron, sans-serif';
            nodeCountInput.style.fontSize = '16px';
            nodeCountInput.style.zIndex = '10';
            document.body.appendChild(nodeCountInput);

            nodeCountInput.addEventListener('change', () => {
                const n = Math.min(200, Math.max(10, parseInt(nodeCountInput.value) || 69));
                nodeCountInput.value = n;
                document.getElementById('label').textContent = `Kn = `;
                generateCompleteGraph(n);
                renderGraph();
            });

            // Remove node count slider from control panel
            const nodeCountLabel = controlPanel.querySelector('label');
            const nodeCountSlider = controlPanel.querySelector('input[type="range"]');
            if (nodeCountLabel) nodeCountLabel.remove();
            if (nodeCountSlider) nodeCountSlider.remove();

            // Remove color intensity slider and make it respond to music
            const colorIntensityLabel = controlPanel.querySelector('label[for="colorIntensity"]');
            const colorIntensitySlider = controlPanel.querySelector('input[type="range"][min="0.5"]');
            if (colorIntensityLabel) colorIntensityLabel.remove();
            if (colorIntensitySlider) colorIntensitySlider.remove();

            // Update color intensity based on audio levels
            function updateColorIntensity(bassLevel, midLevel, trebleLevel) {
                const intensity = 1.0 + (bassLevel * 0.8) + (midLevel * 0.6) + (trebleLevel * 0.4);
                edgeLines.forEach(line => {
                    line.material.opacity = Math.min(1.0, intensity);
                    const currentHue = line.material.color.getHSL({}).h;
                    const currentSat = line.material.color.getHSL({}).s;
                    line.material.color.setHSL(currentHue, currentSat, Math.min(1.0, intensity));
                });
            }

            // Add theme selector
            const themeSelector = document.createElement('select');
            themeSelector.style.marginTop = '10px';
            const themes = ['Default', 'Dark', 'Light', 'Neon'];
            themes.forEach(theme => {
                const option = document.createElement('option');
                option.value = theme.toLowerCase();
                option.innerText = theme;
                themeSelector.appendChild(option);
            });
            themeSelector.onchange = function() {
                switchTheme(themeSelector.value);
            };
            controlPanel.appendChild(themeSelector);

            // Function to switch themes
            function switchTheme(theme) {
                switch (theme) {
                    case 'dark':
                        document.body.style.background = '#0d041a';
                        break;
                    case 'light':
                        document.body.style.background = '#ffffff';
                        break;
                    case 'neon':
                        document.body.style.background = '#000000';
                        break;
                    default:
                        document.body.style.background = '#1a0d2e'; // More vibrant default
                }
            }

            // Add frequency bars
            const frequencyCanvas = document.createElement('canvas');
            frequencyCanvas.style.position = 'fixed';
            frequencyCanvas.style.bottom = '0';
            frequencyCanvas.style.left = '0';
            frequencyCanvas.style.width = '100%';
            frequencyCanvas.style.height = '100px';
            frequencyCanvas.style.zIndex = '5';
            document.body.appendChild(frequencyCanvas);
            const freqCtx = frequencyCanvas.getContext('2d');

            function drawFrequencyBars(audioData) {
                freqCtx.clearRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);
                const barWidth = frequencyCanvas.width / audioData.length;
                audioData.forEach((value, index) => {
                    const barHeight = value / 255 * frequencyCanvas.height;
                    freqCtx.fillStyle = `hsl(${index / audioData.length * 360}, 100%, 50%)`;
                    freqCtx.fillRect(index * barWidth, frequencyCanvas.height - barHeight, barWidth, barHeight);
                });
            }

            // Add waveform display
            const waveformCanvas = document.createElement('canvas');
            waveformCanvas.style.position = 'fixed';
            waveformCanvas.style.bottom = '110px';
            waveformCanvas.style.left = '0';
            waveformCanvas.style.width = '100%';
            waveformCanvas.style.height = '100px';
            waveformCanvas.style.zIndex = '5';
            document.body.appendChild(waveformCanvas);
            const waveCtx = waveformCanvas.getContext('2d');

            function drawWaveform(audioData) {
                waveCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                waveCtx.beginPath();
                waveCtx.moveTo(0, waveformCanvas.height / 2);
                audioData.forEach((value, index) => {
                    const x = index / audioData.length * waveformCanvas.width;
                    const y = (value / 255) * waveformCanvas.height;
                    waveCtx.lineTo(x, y);
                });
                waveCtx.strokeStyle = '#ffd700';
                waveCtx.stroke();
            }

        } catch (error) {
            log('Critical error: ' + error.message);
            console.error('Critical error:', error);
        }
    </script>
</body>
</html>
