<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Hub Tattoo</title>
    <style>
        body {
            margin: 0;
            background: #0d041a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            z-index: 10;
            display: flex;
            gap: 10px;
            flex-direction: column;
        }
        .controls button {
            padding: 10px 15px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 5px;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
        }
        .controls button:hover, .controls button.active {
            background: #ffd700;
            color: #0d041a;
            transform: scale(1.05);
        }
        .label {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 35px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            z-index: 10;
        }
        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #ffd700;
            font-family: monospace;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .audio-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        .audio-controls button {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
        }
        .audio-controls button:hover {
            background: #ffd700;
            color: #0d041a;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
    <!-- Load Stats.js first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <div class="controls">
        <button class="node-btn" data-nodes="1">1</button>
        <button class="node-btn" data-nodes="4">4</button>
        <button class="node-btn active" data-nodes="9">9</button>
        <button onclick="toggleDebug()">Debug</button>
    </div>
    <div class="audio-controls">
        <button onclick="toggleMusic()">ðŸŽµ Toggle Music</button>
    </div>
    <div class="label" id="label">Kn = 9</div>
    <div id="debug"></div>
    
    <script>
        // Debug helper
        const debug = document.getElementById('debug');
        function log(msg) {
            if (debug.style.display === 'block') {
                debug.innerHTML = msg + '<br>' + debug.innerHTML;
                if (debug.innerHTML.split('<br>').length > 10) {
                    debug.innerHTML = debug.innerHTML.split('<br>').slice(0, 10).join('<br>');
                }
            }
        }
        function toggleDebug() {
            debug.style.display = debug.style.display === 'none' ? 'block' : 'none';
        }

        // Stats setup with error handling
        let stats = null;
        try {
            if (typeof Stats === 'function') {
                stats = new Stats();
                stats.showPanel(0);
                document.body.appendChild(stats.dom);
                stats.dom.style.position = 'fixed';
                stats.dom.style.top = '10px';
                stats.dom.style.left = '10px';
                stats.dom.style.zIndex = '1000';
                log('Stats initialized successfully');
            } else {
                log('Warning: Stats.js not loaded properly');
            }
        } catch (error) {
            log('Error initializing Stats: ' + error.message);
        }

        // Music setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let musicPlaying = false;
        let musicSource = null;
        let analyser = null;
        let audioData = null;

        // Generative techno synthesizer
        class TechnoSynth {
            constructor(context) {
                this.context = context;
                this.analyser = context.createAnalyser();
                this.analyser.fftSize = 256;
                this.audioData = new Uint8Array(this.analyser.frequencyBinCount);
                
                // Create nodes
                this.masterGain = context.createGain();
                this.masterGain.gain.value = 0.3; // Reduced overall volume
                this.masterGain.connect(this.analyser);
                this.analyser.connect(context.destination);
                
                // Create compressor for better sound
                this.compressor = context.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.analyser);
                
                // Create oscillators with more musical frequencies
                this.bassOsc = context.createOscillator();
                this.bassOsc.type = 'triangle'; // Changed to triangle for softer bass
                this.bassOsc.frequency.value = 55; // A1
                
                this.midOsc = context.createOscillator();
                this.midOsc.type = 'sine'; // Changed to sine for smoother sound
                this.midOsc.frequency.value = 110; // A2
                
                this.highOsc = context.createOscillator();
                this.highOsc.type = 'sine'; // Changed to sine
                this.highOsc.frequency.value = 220; // A3
                
                // Individual gain nodes for better mixing
                this.bassGain = context.createGain();
                this.bassGain.gain.value = 0.4;
                
                this.midGain = context.createGain();
                this.midGain.gain.value = 0.2;
                
                this.highGain = context.createGain();
                this.highGain.gain.value = 0.1;
                
                // Create filters with gentler settings
                this.bassFilter = context.createBiquadFilter();
                this.bassFilter.type = 'lowpass';
                this.bassFilter.frequency.value = 150;
                this.bassFilter.Q.value = 1;
                
                this.midFilter = context.createBiquadFilter();
                this.midFilter.type = 'bandpass';
                this.midFilter.frequency.value = 800;
                this.midFilter.Q.value = 0.5;
                
                this.highFilter = context.createBiquadFilter();
                this.highFilter.type = 'highpass';
                this.highFilter.frequency.value = 1500;
                this.highFilter.Q.value = 0.5;
                
                // Create LFOs with gentler modulation
                this.bassLFO = context.createOscillator();
                this.bassLFO.frequency.value = 0.2;
                this.bassLFOGain = context.createGain();
                this.bassLFOGain.gain.value = 10;
                
                this.midLFO = context.createOscillator();
                this.midLFO.frequency.value = 0.1;
                this.midLFOGain = context.createGain();
                this.midLFOGain.gain.value = 15;
                
                this.highLFO = context.createOscillator();
                this.highLFO.frequency.value = 0.15;
                this.highLFOGain = context.createGain();
                this.highLFOGain.gain.value = 20;
                
                // Connect everything
                this.bassOsc.connect(this.bassGain);
                this.bassGain.connect(this.bassFilter);
                this.bassFilter.connect(this.masterGain);
                
                this.midOsc.connect(this.midGain);
                this.midGain.connect(this.midFilter);
                this.midFilter.connect(this.masterGain);
                
                this.highOsc.connect(this.highGain);
                this.highGain.connect(this.highFilter);
                this.highFilter.connect(this.masterGain);
                
                // Start oscillators
                this.bassOsc.start();
                this.midOsc.start();
                this.highOsc.start();
                this.bassLFO.start();
                this.midLFO.start();
                this.highLFO.start();

                // Create rhythm
                this.rhythmInterval = 200; // 120 BPM
                this.lastRhythmTime = 0;
            }
            
            update(seed) {
                const now = this.context.currentTime;
                
                // Create a rhythm pattern
                if (now - this.lastRhythmTime >= this.rhythmInterval / 1000) {
                    this.lastRhythmTime = now;
                    this.bassGain.gain.setValueAtTime(0.4, now);
                    this.bassGain.gain.exponentialRampToValueAtTime(0.1, now + 0.1);
                }

                // Use seed for subtle variations
                const bassFreq = 55 + (seed % 5);
                const midFreq = 110 + (seed % 10);
                const highFreq = 220 + (seed % 15);
                
                // Smoother frequency changes
                this.bassOsc.frequency.setTargetAtTime(bassFreq, now, 0.1);
                this.midOsc.frequency.setTargetAtTime(midFreq, now, 0.1);
                this.highOsc.frequency.setTargetAtTime(highFreq, now, 0.1);
                
                // Gentler filter modulation
                const bassMod = Math.sin(now * 0.2) * 30 + 150;
                const midMod = Math.sin(now * 0.1) * 100 + 800;
                const highMod = Math.sin(now * 0.15) * 200 + 1500;
                
                this.bassFilter.frequency.setTargetAtTime(bassMod, now, 0.1);
                this.midFilter.frequency.setTargetAtTime(midMod, now, 0.1);
                this.highFilter.frequency.setTargetAtTime(highMod, now, 0.1);
            }
            
            getAnalyser() {
                return this.analyser;
            }
            
            getAudioData() {
                return this.audioData;
            }
        }

        let synth = null;
        async function toggleMusic() {
            try {
                if (!synth) {
                    synth = new TechnoSynth(audioContext);
                    analyser = synth.getAnalyser();
                    audioData = synth.getAudioData();
                    musicPlaying = true;
                } else {
                    if (musicPlaying) {
                        synth.masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                        musicPlaying = false;
                    } else {
                        synth.masterGain.gain.setValueAtTime(0.5, audioContext.currentTime);
                        musicPlaying = true;
                    }
                }
            } catch (error) {
                log('Error toggling music: ' + error.message);
                console.error('Music error:', error);
            }
        }

        // Scene setup with debugging
        try {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d041a);
            log('Scene created');

            // Create background canvas
            const backgroundCanvas = document.createElement('canvas');
            backgroundCanvas.id = 'background';
            document.body.appendChild(backgroundCanvas);
            const bgCtx = backgroundCanvas.getContext('2d');
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;

            // Create background particles
            const particles = [];
            const particleCount = 100;
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 3 + 1,
                    speed: Math.random() * 2 + 1,
                    angle: Math.random() * Math.PI * 2
                });
            }

            // Background animation function
            function animateBackground(bassLevel, midLevel, trebleLevel) {
                bgCtx.fillStyle = 'rgba(13, 4, 26, 0.1)';
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

                // Update particles
                particles.forEach(particle => {
                    // Audio-reactive movement
                    const audioInfluence = (bassLevel + midLevel + trebleLevel) / 3;
                    particle.angle += (Math.random() - 0.5) * 0.1 * (1 + audioInfluence);
                    particle.x += Math.cos(particle.angle) * particle.speed * (1 + audioInfluence * 0.5);
                    particle.y += Math.sin(particle.angle) * particle.speed * (1 + audioInfluence * 0.5);

                    // Wrap around screen
                    if (particle.x < 0) particle.x = window.innerWidth;
                    if (particle.x > window.innerWidth) particle.x = 0;
                    if (particle.y < 0) particle.y = window.innerHeight;
                    if (particle.y > window.innerHeight) particle.y = 0;

                    // Draw particle with audio-reactive size and color
                    const size = particle.size * (1 + audioInfluence * 2);
                    const hue = (Date.now() * 0.001 + particle.x * 0.001) % 360;
                    bgCtx.fillStyle = `hsla(${hue}, 100%, 70%, ${0.3 + audioInfluence * 0.7})`;
                    bgCtx.beginPath();
                    bgCtx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    bgCtx.fill();
                });

                // Add audio-reactive gradient overlay
                const gradient = bgCtx.createRadialGradient(
                    window.innerWidth / 2,
                    window.innerHeight / 2,
                    0,
                    window.innerWidth / 2,
                    window.innerHeight / 2,
                    Math.max(window.innerWidth, window.innerHeight) * 0.5
                );
                const bassColor = `hsla(${(Date.now() * 0.01) % 360}, 100%, 50%, ${bassLevel * 0.1})`;
                const midColor = `hsla(${(Date.now() * 0.02 + 120) % 360}, 100%, 50%, ${midLevel * 0.1})`;
                const trebleColor = `hsla(${(Date.now() * 0.03 + 240) % 360}, 100%, 50%, ${trebleLevel * 0.1})`;
                
                gradient.addColorStop(0, bassColor);
                gradient.addColorStop(0.5, midColor);
                gradient.addColorStop(1, trebleColor);
                
                bgCtx.globalCompositeOperation = 'overlay';
                bgCtx.fillStyle = gradient;
                bgCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
                bgCtx.globalCompositeOperation = 'source-over';
            }

            // Update background on resize
            window.addEventListener('resize', () => {
                backgroundCanvas.width = window.innerWidth;
                backgroundCanvas.height = window.innerHeight;
            });

            // Viewport helper
            function getViewportSize() {
                return {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    aspect: window.innerWidth / window.innerHeight,
                    min: Math.min(window.innerWidth, window.innerHeight),
                    max: Math.max(window.innerWidth, window.innerHeight)
                };
            }

            // Camera setup
            const viewport = getViewportSize();
            const camera = new THREE.OrthographicCamera(
                -viewport.width / 2,
                viewport.width / 2,
                viewport.height / 2,
                -viewport.height / 2,
                1,
                2000
            );
            camera.position.z = 1000;
            log('Camera initialized at z=' + camera.position.z);

            // Renderer setup with error checking and performance optimizations
            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            
            if (!renderer) {
                throw new Error('Failed to create WebGL renderer');
            }
            
            renderer.setSize(viewport.width, viewport.height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setAnimationLoop(animate); // Use setAnimationLoop for better performance
            document.body.appendChild(renderer.domElement);
            log('Renderer created with size: ' + viewport.width + 'x' + viewport.height);

            // Audio setup for microphone
            let microphoneAnalyser = null;
            let microphoneData = null;
            let isMicrophoneActive = false;

            async function setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioContext.createMediaStreamSource(stream);
                    microphoneAnalyser = audioContext.createAnalyser();
                    microphoneAnalyser.fftSize = 256;
                    microphoneData = new Uint8Array(microphoneAnalyser.frequencyBinCount);
                    source.connect(microphoneAnalyser);
                    isMicrophoneActive = true;
                    log('Microphone setup successful');
                } catch (error) {
                    log('Error setting up microphone: ' + error.message);
                }
            }

            // Add microphone button
            const micButton = document.createElement('button');
            micButton.textContent = 'ðŸŽ¤ Toggle Microphone';
            micButton.style.position = 'fixed';
            micButton.style.top = '80px';
            micButton.style.right = '20px';
            micButton.style.zIndex = '10';
            micButton.style.background = 'rgba(255, 215, 0, 0.2)';
            micButton.style.border = '1px solid #ffd700';
            micButton.style.color = '#ffd700';
            micButton.style.padding = '10px';
            micButton.style.cursor = 'pointer';
            micButton.style.borderRadius = '5px';
            micButton.style.fontFamily = 'Orbitron, sans-serif';
            document.body.appendChild(micButton);

            micButton.addEventListener('click', async () => {
                if (!isMicrophoneActive) {
                    await setupMicrophone();
                    micButton.style.background = '#ffd700';
                    micButton.style.color = '#0d041a';
                } else {
                    isMicrophoneActive = false;
                    micButton.style.background = 'rgba(255, 215, 0, 0.2)';
                    micButton.style.color = '#ffd700';
                }
            });

            // Graph data
            let graph = { nodes: [], edges: [] };
            let nodeSprites = [];
            let edgeLines = [];
            let nodeTrails = []; // Array to store node trails

            // Create node sprite with error checking
            function createNodeSprite(color) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    if (!ctx) {
                        throw new Error('Failed to get 2D context');
                    }

                    const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(0.2, color);
                    gradient.addColorStop(0.4, color.replace(')', ', 0.5)'));
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                    
                    const texture = new THREE.Texture(canvas);
                    texture.needsUpdate = true;
                    
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthTest: false
                    });
                    
                    return new THREE.Sprite(material);
                } catch (error) {
                    log('Error creating sprite: ' + error.message);
                    throw error;
                }
            }

            // Create node trail
            function createNodeTrail(node, color) {
                const trailLength = 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(trailLength * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: new THREE.Color(color),
                    transparent: true,
                    opacity: 0.5,
                    linewidth: 3,
                    blending: THREE.AdditiveBlending
                });
                
                const trail = new THREE.Line(geometry, material);
                trail.userData = {
                    positions: new Array(trailLength).fill().map(() => ({ x: node.x, y: node.y })),
                    color: color
                };
                
                return trail;
            }

            // Create enhanced edge material
            function createEdgeMaterial() {
                return new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 0.6,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    linewidth: 4
                });
            }

            // Create edge glow effect
            function createEdgeGlow(edge, source, target) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    source.x, source.y, 0,
                    target.x, target.y, 0
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 0.3,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    linewidth: 8
                });
                
                return new THREE.Line(geometry, material);
            }

            // Update node trail
            function updateNodeTrail(trail, node, audioLevel) {
                const positions = trail.geometry.attributes.position.array;
                const trailData = trail.userData;
                
                // Shift positions back
                trailData.positions.pop();
                trailData.positions.unshift({ x: node.x, y: node.y });
                
                // Update geometry
                trailData.positions.forEach((pos, i) => {
                    const t = i / trailData.positions.length;
                    positions[i * 3] = pos.x;
                    positions[i * 3 + 1] = pos.y;
                    positions[i * 3 + 2] = 0;
                    
                    // Update opacity based on position in trail
                    trail.material.opacity = (0.5 + audioLevel * 0.5) * (1 - t);
                });
                
                trail.geometry.attributes.position.needsUpdate = true;
                
                // Update color based on audio
                const hue = (Date.now() * 0.001 + audioLevel * 180) % 360;
                trail.material.color.setHSL(hue/360, 1, 0.7);
            }

            // Generate complete graph with error checking
            function generateCompleteGraph(n) {
                try {
                    const viewport = getViewportSize();
                    const radius = Math.min(viewport.width, viewport.height) * 0.3;
                    
                    graph.nodes = Array.from({ length: n }, (_, i) => {
                        const angle = (i * 2 * Math.PI / n);
                        const randRadius = radius * (0.5 + Math.random() * 0.5);
                        return {
                            id: i,
                            x: Math.cos(angle) * randRadius,
                            y: Math.sin(angle) * randRadius,
                            vx: 0,
                            vy: 0,
                            color: `hsl(${(i * 360 / n) % 360}, 100%, 70%)`
                        };
                    });

                    graph.edges = [];
                    for (let i = 0; i < n; i++) {
                        for (let j = i + 1; j < n; j++) {
                            graph.edges.push({ source: i, target: j });
                        }
                    }

                    document.getElementById('label').textContent = `Kn = ${n}`;
                    log(`Generated graph with ${n} nodes and ${graph.edges.length} edges`);
                } catch (error) {
                    log('Error generating graph: ' + error.message);
                    throw error;
                }
            }

            // Render graph with error checking
            function renderGraph() {
                try {
                    // Remove existing elements
                    nodeSprites.forEach(sprite => scene.remove(sprite));
                    edgeLines.forEach(line => scene.remove(line));
                    nodeTrails.forEach(trail => scene.remove(trail));
                    
                    nodeSprites = [];
                    edgeLines = [];
                    nodeTrails = [];

                    // Add nodes and their trails
                    graph.nodes.forEach(node => {
                        const sprite = createNodeSprite(node.color);
                        sprite.position.set(node.x, node.y, 0);
                        sprite.scale.set(100, 100, 1);
                        nodeSprites.push(sprite);
                        scene.add(sprite);
                        
                        const trail = createNodeTrail(node, node.color);
                        nodeTrails.push(trail);
                        scene.add(trail);
                    });

                    // Add edges with enhanced visibility
                    graph.edges.forEach(edge => {
                        const source = graph.nodes[edge.source];
                        const target = graph.nodes[edge.target];
                        
                        // Create main edge line
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            source.x, source.y, 0,
                            target.x, target.y, 0
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const edgeMaterial = createEdgeMaterial();
                        const line = new THREE.Line(geometry, edgeMaterial);
                        edgeLines.push(line);
                        scene.add(line);
                        
                        // Add glow effect
                        const glow = createEdgeGlow(edge, source, target);
                        edgeLines.push(glow);
                        scene.add(glow);
                    });

                    log(`Rendered ${nodeSprites.length} nodes and ${edgeLines.length} edges`);
                } catch (error) {
                    log('Error rendering graph: ' + error.message);
                    throw error;
                }
            }

            // Force simulation with audio reactivity
            function simulate() {
                const viewport = getViewportSize();
                const bounds = Math.min(viewport.width, viewport.height) * 0.4;
                const charge = -800;
                const centerForce = 0.015;
                const damping = 0.98;
                
                // Initialize audio levels
                let bassLevel = 0;
                let midLevel = 0;
                let trebleLevel = 0;
                let overallLevel = 0;
                
                // Get audio data from both music and microphone
                if (analyser && musicPlaying) {
                    analyser.getByteFrequencyData(audioData);
                    bassLevel = average(audioData.slice(0, 4)) / 255;
                    midLevel = average(audioData.slice(4, 12)) / 255;
                    trebleLevel = average(audioData.slice(12, 24)) / 255;
                    overallLevel = average(audioData) / 255;
                    if (synth) synth.update(9);
                }

                if (microphoneAnalyser && isMicrophoneActive) {
                    microphoneAnalyser.getByteFrequencyData(microphoneData);
                    const micBass = average(microphoneData.slice(0, 4)) / 255;
                    const micMid = average(microphoneData.slice(4, 12)) / 255;
                    const micTreble = average(microphoneData.slice(12, 24)) / 255;
                    const micOverall = average(microphoneData) / 255;
                    
                    // Combine music and microphone levels with emphasis on peaks
                    bassLevel = Math.max(bassLevel, micBass * 1.5);
                    midLevel = Math.max(midLevel, micMid * 1.5);
                    trebleLevel = Math.max(trebleLevel, micTreble * 1.5);
                    overallLevel = Math.max(overallLevel, micOverall * 1.5);
                }

                function average(array) {
                    return array.reduce((a, b) => a + b, 0) / array.length;
                }

                // Animate background
                animateBackground(bassLevel, midLevel, trebleLevel);

                // Enhanced time-based modulation for psychedelic effects
                const time = Date.now() * 0.001;
                const pulse = Math.sin(time * 2) * 0.5 + 0.5;
                const swirl = Math.sin(time * 0.5) * 0.5 + 0.5;
                const wave = Math.sin(time * 3) * 0.5 + 0.5;

                // Update node trails
                nodeTrails.forEach((trail, i) => {
                    const node = graph.nodes[i];
                    const audioLevel = (bassLevel + midLevel + trebleLevel) / 3;
                    updateNodeTrail(trail, node, audioLevel);
                });

                // Enhanced edge effects
                edgeLines.forEach((line, i) => {
                    const isGlow = i % 2 === 1; // Every other line is a glow effect
                    const edgeIndex = Math.floor(i / 2);
                    const source = graph.nodes[graph.edges[edgeIndex].source];
                    const target = graph.nodes[graph.edges[edgeIndex].target];
                    
                    const positions = line.geometry.attributes.position.array;
                    
                    if (isGlow) {
                        // Update glow line
                        positions[0] = source.x;
                        positions[1] = source.y;
                        positions[3] = target.x;
                        positions[4] = target.y;
                        
                        // Glow effect properties
                        const glowIntensity = 0.3 + (bassLevel * 0.4) + (pulse * 0.2);
                        line.material.opacity = glowIntensity;
                        line.material.linewidth = 8 + (bassLevel * 4);
                    } else {
                        // Enhanced wave effect to main edge line
                        const midX = (source.x + target.x) / 2;
                        const midY = (source.y + target.y) / 2;
                        const dist = Math.sqrt(
                            Math.pow(target.x - source.x, 2) + 
                            Math.pow(target.y - source.y, 2)
                        );
                        
                        const waveStrength = (trebleLevel * 20) * (1 + wave * 0.5);
                        
                        // Add multiple wave points for smoother curves
                        const segments = 5; // Increased segments for smoother waves
                        for (let j = 0; j <= segments; j++) {
                            const t = j / segments;
                            const x = source.x + (target.x - source.x) * t;
                            const y = source.y + (target.y - source.y) * t;
                            const waveOffset = Math.sin(time * 2 + edgeIndex * 0.1 + t * Math.PI) * waveStrength;
                            positions[j * 3] = x + (target.y - source.y) / dist * waveOffset;
                            positions[j * 3 + 1] = y - (target.x - source.x) / dist * waveOffset;
                        }
                        
                        // Enhanced edge properties
                        const hue = ((time * 20 + edgeIndex * 10) % 360);
                        line.material.color.setHSL(hue/360, 1, 0.8 + trebleLevel * 0.2);
                        line.material.opacity = 0.6 + (midLevel * 0.3) + (pulse * 0.2);
                        line.material.linewidth = 4 + (bassLevel * 4);
                    }
                    
                    line.geometry.attributes.position.needsUpdate = true;
                });

                // Apply forces with enhanced audio reactivity
                graph.nodes.forEach((node, i) => {
                    let fx = 0, fy = 0;

                    // Enhanced repulsion with audio modulation
                    graph.nodes.forEach(other => {
                        if (node !== other) {
                            const dx = node.x - other.x;
                            const dy = node.y - other.y;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            const audioMod = 1 + (bassLevel * 0.5);
                            const force = (charge * audioMod) / (dist * dist + 100);
                            fx += force * dx / dist;
                            fy += force * dy / dist;
                        }
                    });

                    // Enhanced audio-reactive forces
                    if (musicPlaying || isMicrophoneActive) {
                        const angle = (i * 2 * Math.PI / graph.nodes.length) + (swirl * Math.PI * 2);
                        const bassForce = bassLevel * 30 * (1 + pulse * 0.5); // Reduced force
                        const midForce = midLevel * 20 * (1 + Math.sin(time * 3) * 0.3); // Reduced force
                        
                        // Add swirling motion
                        fx += Math.cos(angle) * bassForce;
                        fy += Math.sin(angle) * bassForce;
                        
                        // Add pulsing motion
                        fx += Math.cos(time + i) * midForce;
                        fy += Math.sin(time + i) * midForce;

                        // Enhanced size transitions with pulsing
                        const baseScale = 60 * (1 + midLevel * 0.8); // Reduced size
                        const pulseScale = baseScale * (1 + pulse * 0.3);
                        const currentScale = nodeSprites[i].scale.x;
                        const newScale = currentScale + (pulseScale - currentScale) * 0.15;
                        nodeSprites[i].scale.set(newScale, newScale, 1);

                        // Enhanced color transitions with rainbow effect
                        const hue = ((i * 360 / graph.nodes.length) + (time * 20) + (overallLevel * 180)) % 360;
                        const saturation = 100;
                        const brightness = 60 + trebleLevel * 30 + pulse * 20;
                        node.color = `hsl(${hue}, ${saturation}%, ${brightness}%)`;
                        nodeSprites[i].material.color.setHSL(hue/360, saturation/100, brightness/100);
                        
                        // Add opacity modulation
                        nodeSprites[i].material.opacity = 0.7 + (trebleLevel * 0.3) + (pulse * 0.2);
                    }

                    // Organic boundary forces with stronger containment
                    const distFromCenter = Math.sqrt(node.x * node.x + node.y * node.y);
                    const maxDist = bounds * (0.8 + bassLevel * 0.2); // Reduced maximum distance
                    
                    if (distFromCenter > maxDist) {
                        // Stronger boundary force that increases gradually
                        const boundaryForce = Math.pow((distFromCenter - maxDist) / maxDist, 2) * 0.8;
                        fx -= node.x * boundaryForce;
                        fy -= node.y * boundaryForce;
                    } else {
                        // Gentle center attraction
                        const centerStrength = centerForce * (1 + (bassLevel + midLevel) * 0.3);
                        fx -= node.x * centerStrength;
                        fy -= node.y * centerStrength;
                    }

                    // Update velocity and position with smoother transitions
                    node.vx = (node.vx + fx * 0.1) * damping;
                    node.vy = (node.vy + fy * 0.1) * damping;
                    node.x += node.vx;
                    node.y += node.vy;

                    // Update node position
                    nodeSprites[i].position.set(node.x, node.y, 0);
                });
            }

            // Animation loop with error handling
            function animate() {
                try {
                    if (stats) stats.begin();
                    
                    simulate();
                    renderer.render(scene, camera);
                    
                    if (stats) stats.end();
                } catch (error) {
                    log('Error in animation loop: ' + error.message);
                    console.error('Animation error:', error);
                }
            }

            // Window resize handler
            window.addEventListener('resize', () => {
                try {
                    const viewport = getViewportSize();
                    camera.left = -viewport.width / 2;
                    camera.right = viewport.width / 2;
                    camera.top = viewport.height / 2;
                    camera.bottom = -viewport.height / 2;
                    camera.updateProjectionMatrix();
                    renderer.setSize(viewport.width, viewport.height);
                    log('Resized to: ' + viewport.width + 'x' + viewport.height);
                } catch (error) {
                    log('Error handling resize: ' + error.message);
                }
            });

            // Node count controls
            document.querySelectorAll('.node-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const n = parseInt(btn.dataset.nodes);
                    document.querySelectorAll('.node-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    generateCompleteGraph(n);
                    renderGraph();
                });
            });

            // Initialize
            generateCompleteGraph(69);
            renderGraph();
            log('Initialization complete');

            // Start music automatically
            document.addEventListener('DOMContentLoaded', async () => {
                try {
                    const message = document.createElement('div');
                    message.style.position = 'fixed';
                    message.style.top = '50%';
                    message.style.left = '50%';
                    message.style.transform = 'translate(-50%, -50%)';
                    message.style.background = 'rgba(0,0,0,0.8)';
                    message.style.color = '#ffd700';
                    message.style.padding = '20px';
                    message.style.borderRadius = '10px';
                    message.style.fontFamily = 'Orbitron, sans-serif';
                    message.style.cursor = 'pointer';
                    message.style.zIndex = '1000';
                    message.innerHTML = 'Click anywhere to start the experience';
                    document.body.appendChild(message);

                    const startAudio = async () => {
                        await toggleMusic();
                        message.remove();
                        document.removeEventListener('click', startAudio);
                    };

                    document.addEventListener('click', startAudio, { once: true });
                } catch (error) {
                    log('Error auto-starting music: ' + error.message);
                }
            });

        } catch (error) {
            log('Critical error: ' + error.message);
            console.error('Critical error:', error);
        }
    </script>
</body>
</html>
