<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Hub Tattoo</title>
    <style>
        body {
            margin: 0;
            background: #0d041a;
            overflow: hidden;
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            z-index: 10;
        }
        .controls button {
            padding: 10px 15px;
            margin: 0 5px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 5px;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .controls button:hover, .controls button.active {
            background: #ffd700;
            color: #0d041a;
        }
        .label {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 35px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            z-index: 10;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
</head>
<body>
    <div class="controls">
        <button class="node-btn" data-nodes="1">1</button>
        <button class="node-btn active" data-nodes="4">4</button>
        <button class="node-btn" data-nodes="69">69</button>
    </div>
    <div class="label" id="label">Kn = 4</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2,
            window.innerHeight / 2, window.innerHeight / -2,
            1, 1000
        );
        camera.position.z = 500;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Graph data
        let graph = { nodes: [], edges: [] };
        let nodeSprites = [];
        let edgeLines = [];

        // Generate complete graph Kn
        function generateCompleteGraph(n) {
            graph.nodes = Array.from({ length: n }, (_, i) => ({
                id: i,
                x: (Math.random() - 0.5) * 800,
                y: (Math.random() - 0.5) * 600,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                color: `hsl(${Math.random() * 360}, 80%, 70%)`
            }));
            graph.edges = [];
            for (let u = 0; u < n; u++) {
                for (let v = u + 1; v < n; v++) {
                    graph.edges.push({ source: u, target: v });
                }
            }
            document.getElementById("label").textContent = `Kn = ${n}`;
        }

        // Create node sprite (glowing dot)
        function createNodeSprite(color) {
            const canvas = document.createElement("canvas");
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext("2d");
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, `${color}80`);
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(32, 32, 30, 0, Math.PI * 2);
            ctx.fill();
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({ map: texture });
            return new THREE.Sprite(material);
        }

        // Render graph
        function renderGraph() {
            // Clear previous objects
            nodeSprites.forEach(sprite => scene.remove(sprite));
            edgeLines.forEach(line => scene.remove(line));
            nodeSprites = [];
            edgeLines = [];

            // Add nodes
            graph.nodes.forEach(node => {
                const sprite = createNodeSprite(node.color);
                sprite.position.set(node.x, node.y, 0);
                sprite.scale.set(20, 20, 1);
                nodeSprites.push(sprite);
                scene.add(sprite);
            });

            // Add edges
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                opacity: 0.3,
                transparent: true
            });
            graph.edges.forEach(edge => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    graph.nodes[edge.source].x, graph.nodes[edge.source].y, 0,
                    graph.nodes[edge.target].x, graph.nodes[edge.target].y, 0
                ]);
                const colors = new Float32Array([
                    ...THREE.Color(graph.nodes[edge.source].color).toArray(),
                    ...THREE.Color(graph.nodes[edge.target].color).toArray()
                ]);
                geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
                const line = new THREE.Line(geometry, material);
                edgeLines.push(line);
                scene.add(line);
            });
        }

        // Simple force simulation (in lieu of D3)
        function simulate() {
            const charge = -100;
            const linkDistance = 100;
            graph.nodes.forEach(node => {
                let fx = 0, fy = 0;
                // Repulsion (charge)
                graph.nodes.forEach(other => {
                    if (node !== other) {
                        const dx = node.x - other.x;
                        const dy = node.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                        const force = charge / (dist * dist);
                        fx += force * dx / dist;
                        fy += force * dy / dist;
                    }
                });
                // Attraction (links)
                graph.edges.forEach(edge => {
                    const source = graph.nodes[edge.source];
                    const target = graph.nodes[edge.target];
                    if (source === node || target === node) {
                        const other = source === node ? target : source;
                        const dx = other.x - node.x;
                        const dy = other.y - node.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                        const force = (dist - linkDistance) * 0.01;
                        fx += force * dx / dist;
                        fy += force * dy / dist;
                    }
                });
                node.vx += fx * 0.1;
                node.vy += fy * 0.1;
                node.vx *= 0.95; // Damping
                node.vy *= 0.95;
                node.x += node.vx;
                node.y += node.vy;
            });

            // Update positions
            nodeSprites.forEach((sprite, i) => {
                sprite.position.set(graph.nodes[i].x, graph.nodes[i].y, 0);
            });
            edgeLines.forEach((line, i) => {
                const pos = line.geometry.attributes.position.array;
                pos[0] = graph.nodes[graph.edges[i].source].x;
                pos[1] = graph.nodes[graph.edges[i].source].y;
                pos[3] = graph.nodes[graph.edges[i].target].x;
                pos[4] = graph.nodes[graph.edges[i].target].y;
                line.geometry.attributes.position.needsUpdate = true;
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            simulate();
            renderer.render(scene, camera);
        }

        // Initial setup
        generateCompleteGraph(4);
        renderGraph();
        animate();

        // Node controls
        document.querySelectorAll(".node-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                const n = parseInt(btn.dataset.nodes);
                document.querySelectorAll(".node-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                generateCompleteGraph(n);
                renderGraph();
            });
        });

        document.getElementById("label").addEventListener("click", () => {
            generateCompleteGraph(graph.nodes.length + 1);
            renderGraph();
        });

        // Resize handling
        window.addEventListener("resize", () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
        });

        // Export as image (for tattoo)
        window.addEventListener("keydown", (e) => {
            if (e.key === "s") {
                const link = document.createElement("a");
                link.href = renderer.domElement.toDataURL("image/png");
                link.download = "cosmos_hub_tattoo.png";
                link.click();
            }
        });
    </script>
</body>
</html>
