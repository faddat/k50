<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Hub Tattoo</title>
    <style>
        body {
            margin: 0;
            background: #0d041a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            z-index: 10;
            display: flex;
            gap: 10px;
            flex-direction: column;
        }
        .controls button {
            padding: 10px 15px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 5px;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
        }
        .controls button:hover, .controls button.active {
            background: #ffd700;
            color: #0d041a;
            transform: scale(1.05);
        }
        .label {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 35px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            z-index: 10;
        }
        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #ffd700;
            font-family: monospace;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .audio-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        .audio-controls button {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
        }
        .audio-controls button:hover {
            background: #ffd700;
            color: #0d041a;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
</head>
<body>
    <div class="controls">
        <button class="node-btn" data-nodes="1">1</button>
        <button class="node-btn" data-nodes="4">4</button>
        <button class="node-btn active" data-nodes="369">369</button>
        <button onclick="toggleDebug()">Debug</button>
    </div>
    <div class="audio-controls">
        <button onclick="toggleMusic()">ðŸŽµ Toggle Music</button>
    </div>
    <div class="label" id="label">Kn = 369</div>
    <div id="debug"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js"></script>
    <script>
        // Debug helper
        const debug = document.getElementById('debug');
        function log(msg) {
            if (debug.style.display === 'block') {
                debug.innerHTML = msg + '<br>' + debug.innerHTML;
                if (debug.innerHTML.split('<br>').length > 10) {
                    debug.innerHTML = debug.innerHTML.split('<br>').slice(0, 10).join('<br>');
                }
            }
        }
        function toggleDebug() {
            debug.style.display = debug.style.display === 'none' ? 'block' : 'none';
        }

        // Music setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let musicPlaying = false;
        let musicSource = null;
        let analyser = null;
        let audioData = null;

        // Audio analysis setup
        function setupAudioAnalysis() {
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            audioData = new Uint8Array(analyser.frequencyBinCount);
            return analyser;
        }

        // Get random techno MIDI from repository
        async function getRandomMidiUrl() {
            try {
                const response = await fetch('https://api.github.com/repos/publicsamples/Techno-MIDI/contents/');
                const files = await response.json();
                const midiFiles = files.filter(file => file.name.toLowerCase().endsWith('.mid'));
                const randomMidi = midiFiles[Math.floor(Math.random() * midiFiles.length)];
                return randomMidi.download_url;
            } catch (error) {
                log('Error fetching MIDI list: ' + error.message);
                // Fallback to a default MIDI if GitHub API fails
                return 'https://bitmidi.com/uploads/90939.mid';
            }
        }

        async function setupMusic() {
            try {
                const midiUrl = await getRandomMidiUrl();
                const response = await fetch(midiUrl);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                return audioBuffer;
            } catch (error) {
                log('Error loading music: ' + error.message);
                throw error;
            }
        }

        let audioBuffer = null;
        async function toggleMusic() {
            try {
                if (!analyser) {
                    analyser = setupAudioAnalysis();
                }

                if (!musicSource) {
                    audioBuffer = await setupMusic();
                    musicSource = audioContext.createBufferSource();
                    musicSource.buffer = audioBuffer;
                    musicSource.connect(analyser);
                    analyser.connect(audioContext.destination);
                    musicSource.loop = true;
                    musicSource.start();
                    musicPlaying = true;
                } else {
                    if (musicPlaying) {
                        musicSource.stop();
                        musicPlaying = false;
                    } else {
                        musicSource = audioContext.createBufferSource();
                        musicSource.buffer = audioBuffer;
                        musicSource.connect(analyser);
                        musicSource.loop = true;
                        musicSource.start();
                        musicPlaying = true;
                    }
                }
            } catch (error) {
                log('Error toggling music: ' + error.message);
                console.error('Music error:', error);
            }
        }

        // Scene setup with debugging
        try {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d041a);
            log('Scene created');

            // Viewport helper
            function getViewportSize() {
                return {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    aspect: window.innerWidth / window.innerHeight,
                    min: Math.min(window.innerWidth, window.innerHeight),
                    max: Math.max(window.innerWidth, window.innerHeight)
                };
            }

            // Camera setup
            const viewport = getViewportSize();
            const camera = new THREE.OrthographicCamera(
                -viewport.width / 2,
                viewport.width / 2,
                viewport.height / 2,
                -viewport.height / 2,
                1,
                2000
            );
            camera.position.z = 1000;
            log('Camera initialized at z=' + camera.position.z);

            // Renderer setup with error checking
            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            
            if (!renderer) {
                throw new Error('Failed to create WebGL renderer');
            }
            
            renderer.setSize(viewport.width, viewport.height);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            log('Renderer created with size: ' + viewport.width + 'x' + viewport.height);

            // Stats setup
            const stats = new Stats();
            stats.showPanel(0);
            document.body.appendChild(stats.dom);
            stats.dom.style.position = 'fixed';
            stats.dom.style.top = '10px';
            stats.dom.style.left = '10px';
            stats.dom.style.zIndex = '1000';

            // Graph data
            let graph = { nodes: [], edges: [] };
            let nodeSprites = [];
            let edgeLines = [];

            // Create node sprite with error checking
            function createNodeSprite(color) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    
                    if (!ctx) {
                        throw new Error('Failed to get 2D context');
                    }

                    // Create larger, more visible nodes
                    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(0.3, color);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 128, 128);
                    
                    const texture = new THREE.Texture(canvas);
                    texture.needsUpdate = true;
                    
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    return new THREE.Sprite(material);
                } catch (error) {
                    log('Error creating sprite: ' + error.message);
                    throw error;
                }
            }

            // Generate complete graph with error checking
            function generateCompleteGraph(n) {
                try {
                    const viewport = getViewportSize();
                    const radius = Math.min(viewport.width, viewport.height) * 0.3;
                    
                    graph.nodes = Array.from({ length: n }, (_, i) => {
                        const angle = (i * 2 * Math.PI / n);
                        const randRadius = radius * (0.5 + Math.random() * 0.5);
                        return {
                            id: i,
                            x: Math.cos(angle) * randRadius,
                            y: Math.sin(angle) * randRadius,
                            vx: 0,
                            vy: 0,
                            color: `hsl(${(i * 360 / n) % 360}, 100%, 70%)`
                        };
                    });

                    graph.edges = [];
                    for (let i = 0; i < n; i++) {
                        for (let j = i + 1; j < n; j++) {
                            graph.edges.push({ source: i, target: j });
                        }
                    }

                    document.getElementById('label').textContent = `Kn = ${n}`;
                    log(`Generated graph with ${n} nodes and ${graph.edges.length} edges`);
                } catch (error) {
                    log('Error generating graph: ' + error.message);
                    throw error;
                }
            }

            // Render graph with error checking
            function renderGraph() {
                try {
                    nodeSprites.forEach(sprite => scene.remove(sprite));
                    edgeLines.forEach(line => scene.remove(line));
                    nodeSprites = [];
                    edgeLines = [];

                    const material = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        opacity: 0.2,
                        transparent: true,
                        blending: THREE.AdditiveBlending
                    });

                    // Add nodes
                    graph.nodes.forEach(node => {
                        const sprite = createNodeSprite(node.color);
                        sprite.position.set(node.x, node.y, 0);
                        sprite.scale.set(100, 100, 1);
                        nodeSprites.push(sprite);
                        scene.add(sprite);
                    });

                    // Add edges
                    graph.edges.forEach(edge => {
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            graph.nodes[edge.source].x, graph.nodes[edge.source].y, 0,
                            graph.nodes[edge.target].x, graph.nodes[edge.target].y, 0
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const line = new THREE.Line(geometry, material);
                        edgeLines.push(line);
                        scene.add(line);
                    });

                    log(`Rendered ${nodeSprites.length} nodes and ${edgeLines.length} edges`);
                } catch (error) {
                    log('Error rendering graph: ' + error.message);
                    throw error;
                }
            }

            // Force simulation with audio reactivity
            function simulate() {
                const viewport = getViewportSize();
                const bounds = Math.min(viewport.width, viewport.height) * 0.4;
                const charge = -1000;
                const centerForce = 0.02;
                const damping = 0.95;

                // Get audio data if music is playing
                let bassLevel = 0;
                let midLevel = 0;
                let trebleLevel = 0;
                
                if (analyser && musicPlaying) {
                    analyser.getByteFrequencyData(audioData);
                    
                    // Split frequency data into ranges
                    bassLevel = average(audioData.slice(0, 4)) / 255;  // Low frequencies
                    midLevel = average(audioData.slice(4, 12)) / 255;  // Mid frequencies
                    trebleLevel = average(audioData.slice(12, 24)) / 255;  // High frequencies
                }

                function average(array) {
                    return array.reduce((a, b) => a + b, 0) / array.length;
                }

                // Apply audio-reactive forces
                graph.nodes.forEach((node, i) => {
                    let fx = 0, fy = 0;

                    // Base repulsion
                    graph.nodes.forEach(other => {
                        if (node !== other) {
                            const dx = node.x - other.x;
                            const dy = node.y - other.y;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            const force = charge / (dist * dist);
                            fx += force * dx / dist;
                            fy += force * dy / dist;
                        }
                    });

                    // Audio-reactive forces
                    if (musicPlaying) {
                        // Bass affects node position
                        const angle = (i * 2 * Math.PI / graph.nodes.length);
                        const bassForce = bassLevel * 50;
                        fx += Math.cos(angle) * bassForce;
                        fy += Math.sin(angle) * bassForce;

                        // Mid frequencies affect node size
                        const scale = 100 * (1 + midLevel);
                        nodeSprites[i].scale.set(scale, scale, 1);

                        // Treble affects node color intensity
                        const hue = (i * 360 / graph.nodes.length) % 360;
                        const brightness = 70 + trebleLevel * 30;
                        node.color = `hsl(${hue}, 100%, ${brightness}%)`;
                        nodeSprites[i].material.color = new THREE.Color(node.color);
                    }

                    // Center attraction with audio-reactive strength
                    const centerStrength = centerForce * (1 + (bassLevel + midLevel) * 0.5);
                    fx += -node.x * centerStrength;
                    fy += -node.y * centerStrength;

                    // Update velocity and position
                    node.vx = (node.vx + fx) * damping;
                    node.vy = (node.vy + fy) * damping;
                    node.x += node.vx;
                    node.y += node.vy;

                    // Boundary containment
                    if (Math.abs(node.x) > bounds) {
                        node.x = Math.sign(node.x) * bounds;
                        node.vx *= -0.5;
                    }
                    if (Math.abs(node.y) > bounds) {
                        node.y = Math.sign(node.y) * bounds;
                        node.vy *= -0.5;
                    }

                    // Update node position
                    nodeSprites[i].position.set(node.x, node.y, 0);
                });

                // Update edge positions
                edgeLines.forEach((line, i) => {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = graph.nodes[graph.edges[i].source].x;
                    positions[1] = graph.nodes[graph.edges[i].source].y;
                    positions[3] = graph.nodes[graph.edges[i].target].x;
                    positions[4] = graph.nodes[graph.edges[i].target].y;
                    line.geometry.attributes.position.needsUpdate = true;
                });
            }

            // Animation loop with error handling
            function animate() {
                try {
                    stats.begin();
                    requestAnimationFrame(animate);
                    simulate();
                    renderer.render(scene, camera);
                    stats.end();
                } catch (error) {
                    log('Error in animation loop: ' + error.message);
                    console.error('Animation error:', error);
                }
            }

            // Window resize handler
            window.addEventListener('resize', () => {
                try {
                    const viewport = getViewportSize();
                    camera.left = -viewport.width / 2;
                    camera.right = viewport.width / 2;
                    camera.top = viewport.height / 2;
                    camera.bottom = -viewport.height / 2;
                    camera.updateProjectionMatrix();
                    renderer.setSize(viewport.width, viewport.height);
                    log('Resized to: ' + viewport.width + 'x' + viewport.height);
                } catch (error) {
                    log('Error handling resize: ' + error.message);
                }
            });

            // Node count controls
            document.querySelectorAll('.node-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const n = parseInt(btn.dataset.nodes);
                    document.querySelectorAll('.node-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    generateCompleteGraph(n);
                    renderGraph();
                });
            });

            // Initialize
            generateCompleteGraph(369);
            renderGraph();
            animate();
            log('Initialization complete');

        } catch (error) {
            log('Critical error: ' + error.message);
            console.error('Critical error:', error);
        }
    </script>
</body>
</html>
